{
    "collab_server" : "",
    "contents" : "#' DFA Random Walk (Step 1)\n#'\n#' Convert a vector into a random walk\n#' @param glucose A vector of glucose values from CGM data\n#' @export\n#'\n#'\n\n\nconvert.to.random.walk <- function(glucose){\n\n  stopifnot(is.vector(glucose))\n\n  temp.data <- data.frame(glucose=glucose,\n                          sample=1:length(glucose),\n                          stringsAsFactors=FALSE)\n\n  ## given a bounded time series x_t of length N, where t E N, integration or\n  ## summation first converts this into an unbounded process X_t:\n  ## X_t = sumattion of i=[1, t] of x_i - (x), where (x) denotes the mean value of the time series\n  ## X_t is called cumulative sum or profile. This process converts, for example\n  ## an i.i.d. white noise process into a random walk\n  ts.mean <- mean(temp.data[,'glucose'], na.rm=TRUE)\n\n  temp.data$Bi_meanBi <- temp.data[,'glucose']-ts.mean\n\n  temp.data$Y_k <- cumsum(temp.data$Bi_meanBi)\n\n  return(cgm.rw=temp.data)\n}\n\n\n#' Monofractual Detrended Fluctuation Analysis (Step 2)\n#'\n#' Performed monofractual DFA for a givien dataframe of random walk values and a vector of scales\n#' @param cgm.rw A dataframe of random walk values\n#' @param scale.vect A vector of scales to determine bin sizes for each analyses\n#' @export\n#'\n\nmono.dfa <- function(cgm.rw, scale.vect){\n\n  ## Next, X_t is divided into time windows of length n samples each,\n  ## and a local least square straight-line fit (the local trend) is calculated by\n  ## minimising the squared errors within each time window.\n  ## Let Y_t indicate the resulting piecewise sequence of straight-line fits\n  ## Then, the root-mean-square deviation from the trend, the fluctuation, is calculated:\n  ## F(n) = sqrt of 1/N times summation of t=[1, N] of (X_t - Y_t)^2\n\n  dfa.results <- lapply(scale.vect, function(n){\n    n_in_box <- rep(1:n, floor(dim(cgm.rw)[1]/n))\n    box_n <- rep(1:floor(dim(cgm.rw)[1]/n), each=n)\n\n    cgm.rw.n <- data.table::setDF(cgm.rw)[1:length(n_in_box), ]\n\n    cgm.rw.n$n_in_box <- n_in_box\n    cgm.rw.n$box_n <- box_n\n\n    ## fit linear regressions (take n=[1:n] as x, and y_k as y)\n    cgm.rw.box <- split(cgm.rw.n, f=cgm.rw.n$box_n)\n    cgm.rw.box  <- lapply(cgm.rw.box, function(box){\n      temp.linear.fit <- stats::lm(Y_k~Samples, data=box)\n      box$Slope <- temp.linear.fit$coefficients[2]\n      box$Intercept <- temp.linear.fit$coefficients[1]\n      box$Y_nk <- (box$Samples*box$Slope) + box$Intercept\n      box$Y_k_Y_nk <- (box$Y_k-box$Y_nk)^2\n      box$RMS <- sqrt(mean(box$Y_k_Y_nk))\n      return(box)\n    })\n\n    cgm.rw.n <- data.table::rbindlist(cgm.rw.box)\n    F_n <- sqrt(sum(cgm.rw.n$Y_k_Y_nk)/dim(cgm.rw.n)[1])\n\n    F_ns.df <- data.frame(n=n, F_n=F_n, stringsAsFactors=FALSE)\n\n    return(list(F_ns.df=F_ns.df, cgm.rw.box=cgm.rw.box))\n  })\n\n  cgm.rw.box <- lapply(dfa.results, function(x) x$cgm.rw.box)\n  f.ns <- lapply(dfa.results, function(x) x$F_ns.df)\n\n\n  ## compute power law relation between overall RMS, indicated by the slope of regression between scales and fluctuation\n  fluctuation.scale.df <- data.frame(scale=unlist(sapply(f.ns, function(x) x$n)),\n                                     fluctuation=unlist(sapply(f.ns, function(x) x$F_n)),\n                                     stringsAsFactors=FALSE)\n\n  C <- stats::glm(log(fluctuation.scale.df$fluctuation)~log(fluctuation.scale.df$scale), family='gaussian')\n\n\n\n  return(list(dfa.results=cgm.rw.box,\n              fluctuation.scale.df=fluctuation.scale.df,\n              Hurst_Exponent=as.numeric(C$coefficients[2])))\n}\n\n\n\n\n\n\n#' Multifractual Detrended Fluctuation Analysis (Step 3)\n#'\n#' Performed monofractual DFA for a givien dataframe of random walk values and a vector of scales\n#' @param mono.dfa.test A monofractual DFA analysis output\n#' @param q.vect A vector of scales for the q-th order statistics\n#' @param scale.vect A vector of scales to determine bin sizes for each analyses\n#' @export\n\n\nmulti.dfa <- function(mono.dfa.test, q.vect, scale.vect){\n\n  ## extract the RMS from the dfa.object for all scales\n  rms.list <- lapply(mono.dfa.test$dfa.results, function(dfa.scale){\n    lapply(dfa.scale, function(dfa.box){\n      dfa.box$RMS[1]\n    })\n  })\n\n  rms.list <- lapply(rms.list, unlist)\n\n  q.rms.list <- lapply(rms.list, function(rms){\n    Fq.list <- lapply(q.vect, function(q){\n      qrms <- rms^q\n      if(q!=0){\n        Fq <- mean(qrms)^(1/q)\n      }else{\n        Fq <- exp(0.5*mean(log(rms^2)))\n      }\n      return(data.frame(Fq=Fq, q=q))\n    })\n    Fq.df <- do.call(rbind, Fq.list)\n    return(Fq.df)\n  })\n\n  q.rms.list <- mapply(function(qrms, scale.n){\n    qrms$scale <- scale.n\n    return(qrms)\n  }, qrms=q.rms.list, scale.n=scale.vect, SIMPLIFY=FALSE)\n\n  Fq <- do.call(rbind, q.rms.list)\n\n\n  ### fit regression model between scale and Fq\n  Fq.list <- split(Fq, f=Fq$q)\n  Fq.reg.list <- lapply(Fq.list, function(x){\n\n    ### q-order of Hurst exponent can be defined as the slopes of regression lines\n    ### for each q-order RSMS\n    q.fq.fit <- stats::glm(log2(x$Fq)~log2(x$scale), family='gaussian')\n\n    return(q.fq.fit)\n\n  })\n\n  ### Hurst exponent\n  Hq.list <- lapply(Fq.reg.list, function(x){\n    as.numeric(x$coefficients[2])\n  })\n  Hq.list <- unlist(Hq.list)\n\n  fitted.list <- lapply(Fq.reg.list, function(x){\n    stats::fitted(x)\n  })\n\n\n  ### convert Hq to the q-order mass exponent (tq)\n  tq.list <- lapply(names(Hq.list), function(q){\n    Hq.temp <- Hq.list[[q]]\n    q.temp <- as.numeric(q)\n    (q.temp*Hq.temp)-1\n  })\n  tq.list <- unlist(tq.list)\n\n  ### convert q-order mass exponent to q-order singularity exponent\n  ### ## subtract t_q(i+1) - t_q(i)\n  singularity.exp.q.list.top <- tq.list[2:length(tq.list)]-tq.list[1:(length(tq.list)-1)]\n  singularity.exp.q.list.bottom <- q.vect[2:length(q.vect)]-q.vect[1:(length(q.vect)-1)]\n  singularity.exp.q.list <- singularity.exp.q.list.top/singularity.exp.q.list.bottom\n\n  ### q-order singularity dimension\n  Dq <- (q.vect[1:(length(q.vect)-1)]*singularity.exp.q.list)-(tq.list[1:(length(q.vect)-1)])\n\n\n  return(list(Fq=Fq,\n              Fq.reg.list=Fq.reg.list,\n              HurstExponent=Hq.list,\n              MassExponent=tq.list,\n              SingularityExponent=singularity.exp.q.list,\n              SingularityDimension=Dq))\n\n}\n\n\n\n\n#' Local Fluctuation (Step 4)\n#'\n#' Performed monofractual DFA for a givien dataframe of random walk values and a vector of scales\n#' @param cgm.rw A dataframe of random walk values\n#' @param multi.dfa.test A multifractual DFA analysis output\n#' @param scale_small A vector of \"small\" scales to determine bin sizes for each analyses\n#' @export\n\n\nlocal.fluctuation.hurst <- function(cgm.rw, multi.dfa.test, scale_small){\n\n  halfmax <- floor(max(scale_small)/2)\n\n  time_index <- (halfmax+1):(dim(cgm.rw)[1]-halfmax)\n\n\n  ### fit regression using small scales to compute local fluctuation\n  local.fluctuation.list <- lapply(scale_small, function(n){\n\n    halfseg <- floor(n/2)\n    fit.list <- lapply(time_index, function(v){\n      T_index <- (v-halfseg):(v+halfseg)\n      C <- stats::glm(cgm.rw$Y_k[T_index]~T_index, family='gaussian')\n      C.fitted <- stats::fitted(C)\n      RMS <- sqrt(mean((cgm.rw$Y_k[T_index]-C.fitted)^2))\n      return(RMS)\n    })\n    rms <- unlist(fit.list)\n    return(rms)\n  })\n  names(local.fluctuation.list) <- scale_small\n\n  ### compute local Hurst exponent (Ht) from local fluctuation\n  multi.fq.0 <- multi.dfa.test$Fq\n  multi.fq.0 <- multi.fq.0[which(multi.fq.0$q==0), ]\n  c.fit <- stats::glm(log2(Fq)~log2(scale), data=multi.fq.0, family='gaussian')\n\n  predict.scale.small <- c.fit$coefficients[1]+c.fit$coefficients[2]*log2(scale_small)\n  names(predict.scale.small) <- scale_small\n\n  maxL <- dim(cgm.rw)[1]\n\n  local.Hurst <- lapply(names(local.fluctuation.list), function(n){\n\n    RMSt <- local.fluctuation.list[[n]]\n    resRMS <- predict.scale.small[n] - log2(RMSt)\n    logscale <- log2(maxL)-log2(as.numeric(n))\n    Hurst_t <- resRMS/(logscale+multi.dfa.test$HurstExponent[names(multi.dfa.test$HurstExponent)==0])\n\n  })\n\n\n}\n\n\n\n\n",
    "created" : 1558719922301.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3816827990",
    "id" : "2D8DAC9E",
    "lastKnownWriteTime" : 1558721847,
    "last_content_update" : 1558721855455,
    "path" : "R:/PrevMed/Projects/HAPO/Alan/CGM/Scripts/wiseCGM/R/dfa.functions.R",
    "project_path" : "R/dfa.functions.R",
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}