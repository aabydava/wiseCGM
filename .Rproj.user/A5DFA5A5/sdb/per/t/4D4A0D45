{
    "collab_server" : "",
    "contents" : "#' Format DEXCOM data\n#'\n#' Format DEXCOM data into an analyzable dataframe.\n#' @param input.path: The name of the file which the data are to be read from.\n#' @param rds.out: The name of the output file\n#' @export\n#'\nformat_dexcom <- function(input.path, rds.out=NULL){\n  if(grepl('xls', input.path)){\n    dexcom <- xlsx::read.xlsx(input.path, sheetIndex=1, check.names=FALSE,\n                              stringsAsFactors=FALSE,\n                              colClasses=c('integer', rep('character', 6), rep('numeric', 2), 'POSIXct', rep('numeric', 2), 'character'))\n    if(is.null(rds.out)){\n      rds.out <- gsub('xls', 'RDS', input.path)\n    }\n\n    dexcom[, grep('Duration', names(dexcom), value=TRUE)] <- strftime(dexcom[, grep('Duration', names(dexcom), value=TRUE)],\n                                                                      format='%H:%M:%S', tz='UTC')\n\n  }else{\n    dexcom <- read.csv(input.path, header=TRUE, stringsAsFactors=FALSE,\n                       check.names=FALSE, na.strings='')\n    if(is.null(rds.out)){\n      rds.out <- gsub('csv', 'RDS', input.path)\n    }\n  }\n\n  names(dexcom) <- gsub(':|\\\\/| |-', '_', names(dexcom))\n  names(dexcom) <- gsub('\\\\(|\\\\)', '', names(dexcom))\n  #names(dexcom)[grepl('Index', names(dexcom))] <- 'Index'\n\n  meta.data <- dexcom[which(is.na(dexcom$Timestamp_YYYY_MM_DDThh_mm_ss)), ]\n\n  ## delete columns with only NAs\n  remove.meta.cols <- sapply(meta.data, function(x) sum(is.na(x)))\n  keep.meta.cols <- names(remove.meta.cols)[remove.meta.cols < nrow(meta.data)]\n  meta.data <- meta.data[, keep.meta.cols]\n\n  if('Patient_Info' %in% names(meta.data)){\n    patient.meta.data <- meta.data[grep('FirstName|LastName|DateOfBirth', meta.data$Event_Type),\n                                   c('Event_Type','Patient_Info')]\n  }else{\n    patient.meta.data <- NULL\n  }\n\n  meta.data <- meta.data[-grep('FirstName|LastName|DateOfBirth', meta.data$Event_Type), ]\n\n  meta.data.list <- split(meta.data, f=meta.data$Source_Device_ID)\n  meta.data.list <- lapply(meta.data.list, function(meta){\n    meta$Device_Info[is.na(meta$Device_Info)] <- meta$Device_Info[!is.na(meta$Device_Info)];meta\n    meta <- meta[!grepl('Device', meta$Event_Type), ]\n  })\n\n  #names(meta.data.list) <- paste0('Alert ', names(meta.data.list))\n\n  #meta.data <- do.call(rbind, meta.data.list)\n\n  if(!is.null(patient.meta.data)){\n    meta.data.list <- c(list(patient.meta.data), meta.data.list)\n    names(meta.data.list)[1] <- 'Patient Information'\n  }\n\n  ## informative meta data\n  informative.meta.data <- lapply(meta.data.list, function(mdl){\n    mdl <- mdl[, c('Event_Subtype', 'Glucose_Value_mg_dL')]\n    mdl <- as.data.frame.matrix(t(mdl), stringsAsFactors=FALSE)\n    names(mdl) <- mdl[1, ]\n    mdl <- mdl[2, ]\n    mdl <- mdl[, !is.na(mdl)]\n    return(mdl)\n  })\n\n\n  ## dexcom cgm data\n  cgm.data <- dexcom[-which(is.na(dexcom$Timestamp_YYYY_MM_DDThh_mm_ss)), ]\n\n  ## delete columns with only NAs\n  remove.cgm.cols <- sapply(cgm.data, function(x) sum(is.na(x)))\n  keep.cgm.cols <- names(remove.cgm.cols)[remove.cgm.cols < nrow(cgm.data)]\n\n  cgm.data <- cgm.data[, keep.cgm.cols[!grepl('Index', keep.cgm.cols)]]\n\n  ## create date / time variable variable\n  cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss <- gsub('T', ' ', cgm.data$Timestamp_YYYY_MM_DDThh_mm_ss)\n  #cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss  <- gsub('\\\\..*', '', cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss )\n  cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss <- base::as.POSIXct(lubridate::parse_date_time(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss,\n                                                                                        c(\"mdy HM\", \"mdy HMS\", \"mdY HM\", \"mdY HMS\",\n                                                                                          \"dmy HM\", \"dmy HMS\", \"dmY HM\", \"dmY HMS\", \"Ymd HM\", \"Ymd HMS\",\n                                                                                          \"ymd HM\", \"ymd HMS\", \"Ydm HM\", \"Ydm HMS\", \"ydm HM\", \"ydm HMS\")),\n                                                             tz='UTC')\n\n  cgm.data$Timestamp_YYYY_MM_DDThh_mm_ss <- NULL\n\n  cgm.data$Date <- as.Date(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss)\n  cgm.data$Year <- lubridate::year(cgm.data$Date)\n  cgm.data$Month <- lubridate::month(cgm.data$Date)\n  cgm.data$Day <- lubridate::day(cgm.data$Date)\n  cgm.data$WeekDay <- factor(base::weekdays(cgm.data$Date, abbreviate=FALSE),\n                             levels=weekdays(x=as.Date(0:6, origin='1950-01-01')))\n  cgm.data$Time <- strftime(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss, format='%H:%M:%S', tz='UTC')\n  cgm.data$Hour <- lubridate::hour(strftime(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss, fomrat='%H:%M:%S', tz='UTC'))\n  cgm.data$Min <- lubridate::minute(strftime(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss, fomrat='%H:%M:%S', tz='UTC'))\n  cgm.data$Sec <- lubridate::second(strftime(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss, fomrat='%H:%M:%S', tz='UTC'))\n\n  cgm.data$Day_Time <- cgm.data$Day + ((cgm.data$Hour*60*60) + (cgm.data$Min*60) + (cgm.data$Sec))/86400\n\n  cgm.data$TP <- month.name[cgm.data$Month]\n\n  ## create a column to indicate levels of glucose warnings\n  cgm.data$EGV_Warnings <- ifelse(cgm.data$Event_Type=='EGV' & grepl('^[A-Za-z]+$', cgm.data$Glucose_Value_mg_dL),\n                                  cgm.data$Glucose_Value_mg_dL, NA)\n  cgm.data$Glucose_Value_mg_dL <- as.numeric(cgm.data$Glucose_Value_mg_dL)\n\n  cgm.data.list <- split(cgm.data, f=cgm.data$Source_Device_ID)\n\n  ## determine if glucose variable is within, above, or below target\n  cgm.data.list <- lapply(names(cgm.data.list), function(device){\n    check <- meta.data.list[[device]]\n    urgent.low <- as.numeric(check$Glucose_Value_mg_dL[which(check$Event_Subtype=='Urgent Low')])\n    low <- as.numeric(check$Glucose_Value_mg_dL[which(check$Event_Subtype=='Low')])\n    high <- as.numeric(check$Glucose_Value_mg_dL[which(check$Event_Subtype=='High')])\n    temp <- cgm.data.list[[device]]\n    temp$TARGET <- sapply(temp[,'Glucose_Value_mg_dL'], function(x){\n      ifelse(is.na(x), NA,\n             ifelse(x <= urgent.low, 'Urgent Low',\n                    ifelse(x > urgent.low & x <= low, 'Low',\n                           ifelse(x >= high, 'High', 'On Target'))))\n    })\n    return(temp)\n  })\n\n  cgm.data <- do.call(rbind, cgm.data.list)\n  cgm.data <- cgm.data[order(cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss), ]\n\n  if(any(!names(cgm.data) %in% 'Event_Subtype')){\n    cgm.data[, 'Event_Subtype'] <- NA\n  }\n\n  ## create a copy without the high/low values in glucouse value mg dl column\n  cgm.data.sub <- cgm.data\n  cgm.data.sub <- cgm.data.sub[, !names(cgm.data.sub) %in% 'Event_Subtype']\n\n  ## number of calibration(s) each day\n  date.calibrations <- as.data.frame(table(cgm.data.sub$Event_Type, cgm.data.sub$Date), stringsAsFactors=FALSE)\n  date.calibrations <- date.calibrations[which(date.calibrations$Var1=='Calibration'), ]\n\n  ## determine what device were used\n  ## if before Dexcom G6, remove those with less than 2 calibration\n  if(any(sapply(meta.data.list,function(mdl) all(mdl$Device_Info!='Dexcom G6 Mobile App')))){\n    before.g6 <- which(sapply(meta.data.list,function(mdl) all(mdl$Device_Info!='Dexcom G6 Mobile App')))\n    names(before.g6) <- gsub('Alert ', '', names(before.g6))\n    cgm.device <- split(cgm.data.sub, f=cgm.data.sub$Source_Device_ID)\n    cgm.device <- lapply(names(cgm.device), function(x){\n      if(x %in% names(before.g6)){\n        temp <- cgm.device[[x]]\n        ## dates with 2 or more calibrations\n        date.calibrations <- date.calibrations[which(date.calibrations$Freq >= 2), ]\n        date.calibrations$Var2 <- as.Date(date.calibrations$Var2)\n        temp <- temp[temp$Date %in% date.calibrations$Var2, ]\n        return(temp)\n      }else{\n        cgm.device[[x]]\n      }\n    })\n    cgm.data.sub <- do.call(rbind, cgm.device)\n  }\n\n  if(dim(cgm.data.sub)[1] != 0){\n    ## remove calibrations?\n    cgm.data.sub <- cgm.data.sub[which(cgm.data.sub$Event_Type!='Calibration'), ]\n\n    ## remove NAs (low/high)\n    cgm.data.sub <- cgm.data.sub[!is.na(cgm.data.sub$Glucose_Value_mg_dL), ]\n\n    ## number of calibration(s) each day\n    date.calibrations <- data.frame(Dates=unique(cgm.data.sub$Date), stringsAsFactors=FALSE)\n\n    ## check for consecutive dates\n    dates <- sort(date.calibrations$Dates)\n    dates.group <- split(dates, cumsum(c(TRUE, diff(dates)!=1)))\n\n    ## split cgm data into groups based on dates\n    cgm.data.sub.dates <- lapply(dates.group, function(dg){\n      temp <- cgm.data.sub[cgm.data.sub$Date %in% dg, ]\n      temp <- temp[order(temp$Timestamp_YYYY_MM_DD_hh_mm_ss), ]\n      temp$Glucose_Value_mg_dL_v2 <- NA\n      #temp$Time_diff <- c(TRUE, diff(temp$Timestamp_YYYY_MM_DD_hh_mm_ss) > 270 & diff(temp$Timestamp_YYYY_MM_DD_hh_mm_ss) < 630)\n      for(i in 3:(nrow(temp)-2)){\n        check.value <- temp[i, 'Glucose_Value_mg_dL']\n        intermediate.sv <- temp[((i-2):(i+2))[!((i-2):(i+2)) %in% i], ]\n        i.sv.mean <- mean(intermediate.sv$Glucose_Value_mg_dL, na.rm=TRUE)\n        i.sv.sd <- sd(intermediate.sv$Glucose_Value_mg_dL, na.rm=TRUE)\n\n        upp.b <- i.sv.mean + i.sv.sd\n        low.b <- i.sv.mean - i.sv.sd\n\n        if(!(check.value >= low.b & check.value <= upp.b)){\n          temp[i, 'Glucose_Value_mg_dL_v2'] <- i.sv.mean\n        }\n        temp$Glucose_Value_mg_dL_v2[is.na(temp$Glucose_Value_mg_dL_v2)] <- temp$Glucose_Value_mg_dL[is.na(temp$Glucose_Value_mg_dL_v2)]\n\n      }\n\n      return(temp)\n    })\n\n    cgm.data.sub <- do.call(rbind, cgm.data.sub.dates)\n  }\n\n  cgm.data$Timestamp_YYYY_MM_DD_hh_mm_ss <- cgm.data$Transmitter_Time_Long_Integer <- NULL\n\n  cgm.data.sub <- cgm.data.sub[order(cgm.data.sub$Timestamp_YYYY_MM_DD_hh_mm_ss), ]\n  cgm.data.sub$Timestamp_YYYY_MM_DD_hh_mm_ss <- cgm.data.sub$Transmitter_Time_Long_Integer <- NA\n\n  meta.data.list <- lapply(meta.data.list, function(mdl){\n    mdl$TP <- unique(cgm.data$TP);mdl\n  })\n\n  informative.meta.data <- lapply(informative.meta.data, function(mdl){\n    mdl$TP <- unique(cgm.data$TP); mdl\n  })\n\n  saveRDS(list(full.cgm.data=cgm.data,\n               cleaned.cgm.data=cgm.data.sub,\n               meta.data=meta.data.list,\n               informative.meta.data=informative.meta.data),\n          file=rds.out)\n}\n",
    "created" : 1550267150011.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "808793202",
    "id" : "4D4A0D45",
    "lastKnownWriteTime" : 1550516915,
    "last_content_update" : 1550516776493,
    "path" : "R:/PrevMed/Projects/HAPO/Alan/CGM/Scripts/wiseCGM/R/format_dexcom.R",
    "project_path" : "R/format_dexcom.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}